{
    "collab_server" : "",
    "contents" : "\n#' Sample size and power for logistic regression with a binary covariate.\n#'\n#' A function for calculating sample size and power based on logistic regression. The function solves for one of the following: alpha, power, OR, N. Assume the predictor is binary.\n#' @param alpha type I error rate. Can range from 0 to 1 (typically 0.05)\n#' @param power 1 - Pr(type II error) Can range from 0 to 1 (typically 0.80)\n#' @param P0 baseline probability that Y=1\n#' @param OR odds ratio (odds(Y=1|X=1) / odds(Y=1|X=0))\n#' @param R proportion of sample (N) with X1=1\n#' @param N sample size\n#' @return Return one of the following parameters\n#' @return \\code{alpha}, \\code{power}, \\code{OR}, \\code{N}\n#' @note The test is a two-sided test. For one-sided tests, double the significance level. For example, you can set alpha=0.10 to obtain one-sided test at 0.05 significance level.\n#' @author David Aaby <david.aaby@@northwestern.edu>\n#' @references Hsieh, F.Y., Block, D.A., and Larsen, M.D. 1998. A Simple Method of Sample Size Calculation for Linear and Logistic Regression, Statistics in Medicine, Volume 17, pages 1623-1634.\n#' @export Logpower.bin\n#' @import stats\n#' @examples\n#' Logpower.bin(alpha=0.05, power=.90, P0=0.07, OR=1.5, R=.50)            #outputs N\n#' Logpower.bin(alpha=0.05, power=.90, P0=0.07, OR=c(1.5,2.0), R=.50)     #outputs a vector of Ns\n#' Logpower.bin(alpha=0.05, power=.90, P0=0.07, R=.50, N=3326)            #outputs OR\n#' Logpower.bin(power=.90, P0=0.07, OR=1.5, R=.50, N=3326)                #outputs alpha\n#' Logpower.bin(alpha=0.05, P0=0.07, OR=1.5, R=.50, N=3326)               #outputs beta\n\n\n\nLogpower.bin <- function(alpha=NULL, power=NULL, P0=NULL, OR=NULL, R=NULL, N=NULL) {\n\n  if(any(alpha < 0 | alpha > 1)) stop('alpha not between 0 and 1')\n  if(any(power < 0 | power > 1)) stop('power not between 0 and 1')\n  if(any(P0 < 0 | P0 > 1))       stop('P0 not between 0 and 1')\n  if(any(R < 0 | R > 1))         stop('R not between 0 and 1')\n  if(any(OR < 0))                stop('OR not a positive value')\n  if(any(N < 2))                 stop('N is less than 2')\n\n  mylist = list(alpha, power, P0, OR, N)\n  l.mylist = lengths(mylist)\n  if(length(l.mylist[l.mylist>=2]) > 1) stop('Only vary one parameter at a time')\n\n\n\n  if(is.null(alpha)) {\n    beta = 1 - power\n    P1 = (P0*OR) / (OR*P0 + 1 - P0)\n    Pbar = (1-R)*P0 + R*P1\n\n    A1 = sqrt(N*((P0-P1)^2)*(1-R))\n    A2 = stats::qnorm(1-beta)*sqrt(P0*(1-P0) + ((P1*(1-P1)*(1-R))/R))\n    A3 = sqrt(Pbar*(1-Pbar)/R)\n    A4 = (A1 - A2) / A3\n\n    alpha = 2*(1-stats::pnorm(A4))\n    alpha = round(alpha,3)\n\n    P1 = round(P1,3)\n\n\n    results = NULL\n\n    if(length(power) > 1 | length(P0) > 1 | length(OR) > 1 | length(N) > 1) {\n      rownum = max(length(alpha), length(power), length(P0), length(OR))\n      for(i in 1:rownum) {\n        results = cbind(alpha, power, P0, P1, OR, R, N)\n      }\n    }\n\n    else {\n      results = c(alpha, power, P0, P1, OR, R, N)\n      results = data.frame(results)\n      results = t(results)\n      colnames(results) = c(\"alpha\", \"power\", \"P0\", \"P1\", \"OR\", \"R\" ,\"N\")\n    }\n  }\n\n\n  if(is.null(power)) {\n\n    P1 = (P0*OR) / (OR*P0 + 1 - P0)\n    Pbar = (1-R)*P0 + R*P1\n\n    A1 = sqrt(N*((P0-P1)^2)*(1-R))\n    A2 = stats::qnorm(1-alpha/2)* sqrt(Pbar*(1-Pbar)/R)\n    A3 = sqrt(P0*(1-P0) + ((P1*(1-P1)*(1-R))/R))\n    A4 = (A1 - A2) / A3\n\n    power = stats::pnorm(A4)\n    power = round(power,3)\n\n    P1 = round(P1,3)\n\n\n    results = NULL\n\n    if(length(alpha) > 1 | length(P0) > 1 | length(OR) > 1 | length(N) > 1) {\n      rownum = max(length(alpha), length(power), length(P0), length(OR))\n      for(i in 1:rownum) {\n        results = cbind(alpha, power, P0, P1, OR, R, N)\n      }\n    }\n\n    else {\n      results = c(alpha, power, P0, P1, OR, R, N)\n      results = data.frame(results)\n      results = t(results)\n      colnames(results) = c(\"alpha\", \"power\", \"P0\", \"P1\", \"OR\", \"R\" ,\"N\")\n    }\n  }\n\n\n  if(is.null(OR)) {\n\n    beta = 1 - power\n    P1 = seq(0, .90, .00001)\n    N1 = N\n    OR = NULL\n    P1.new = NULL\n\n    maxlength = max(c(length(alpha), length(power), length(P0), length(N)))\n    if(maxlength==1) {\n\n      for(i in 1:length(P0)) {\n        Pbar = (1-R)*P0[i] + R*P1\n        n = (((stats::qnorm(1-alpha/2)* sqrt(Pbar*(1-Pbar)/R)) +\n              (stats::qnorm(1-beta)*sqrt(P0[i]*(1-P0[i]) + ((P1*(1-P1)*(1-R))/R))))^2) /\n        (((P0[i]-P1)^2) * (1-R))\n\n        or = (P1*(1-P0[i])) / (P0[i]*(1-P1))\n        N.N1 = abs(n - N1)\n        foo = cbind(P1,N,or, N.N1)\n        foo = foo[which(foo[,3] >= 1),]\n        x = foo[which.min(foo[,4]),]\n\n        or = x[[3]]\n        OR = c(OR, or)\n        OR = round(OR,3)\n\n        p1 = x[[1]]\n        P1.new = c(P1.new, p1)\n        P1.new = round(P1.new,3)\n      }\n    } else {\n      if (length(P0) > 1) {\n        for(i in 1:length(P0)) {\n          Pbar = (1-R)*P0[i] + R*P1\n          n = (((stats::qnorm(1-alpha/2)* sqrt(Pbar*(1-Pbar)/R)) +\n                (stats::qnorm(1-beta)*sqrt(P0[i]*(1-P0[i]) + ((P1*(1-P1)*(1-R))/R))))^2) /\n          (((P0[i]-P1)^2) * (1-R))\n\n          or = (P1*(1-P0[i])) / (P0[i]*(1-P1))\n          N.N1 = abs(n - N1)\n          foo = cbind(P1,N,or, N.N1)\n          foo = foo[which(foo[,3] >= 1),]\n          x = foo[which.min(foo[,4]),]\n\n          or = x[[3]]\n          OR = c(OR, or)\n          OR = round(OR,3)\n\n          p1 = x[[1]]\n          P1.new = c(P1.new, p1)\n          P1.new = round(P1.new,3)\n        }\n      }\n\n      if(length(N) > 1) {\n        for(i in 1:length(N)) {\n          Pbar = (1-R)*P0 + R*P1\n          n = (((stats::qnorm(1-alpha/2)* sqrt(Pbar*(1-Pbar)/R)) +\n                  (stats::qnorm(1-beta)*sqrt(P0*(1-P0) + ((P1*(1-P1)*(1-R))/R))))^2) /\n            (((P0-P1)^2) * (1-R))\n\n          or = (P1*(1-P0)) / (P0*(1-P1))\n          N.N1 = abs(n - N1[i])\n          foo = cbind(P1, N[i], or, N.N1)\n          foo = foo[which(foo[,3] >= 1),]\n          x = foo[which.min(foo[,4]),]\n\n          or = x[[3]]\n          OR = c(OR, or)\n          OR = round(OR,3)\n\n          p1 = x[[1]]\n          P1.new = c(P1.new, p1)\n          P1.new = round(P1.new,3)\n        }\n      }\n\n      if(length(alpha) > 1) {\n        for(i in 1:length(alpha)) {\n          Pbar = (1-R)*P0 + R*P1\n          n = (((stats::qnorm(1-alpha[i]/2)* sqrt(Pbar*(1-Pbar)/R)) +\n                  (stats::qnorm(1-beta)*sqrt(P0*(1-P0) + ((P1*(1-P1)*(1-R))/R))))^2) /\n            (((P0-P1)^2) * (1-R))\n\n          or = (P1*(1-P0)) / (P0*(1-P1))\n          N.N1 = abs(n - N1)\n          foo = cbind(P1, N, or, N.N1)\n          foo = foo[which(foo[,3] >= 1),]\n          x = foo[which.min(foo[,4]),]\n\n          or = x[[3]]\n          OR = c(OR, or)\n          OR = round(OR,3)\n\n          p1 = x[[1]]\n          P1.new = c(P1.new, p1)\n          P1.new = round(P1.new,3)\n        }\n      }\n\n      if(length(power) > 1) {\n        for(i in 1:length(power)) {\n          Pbar = (1-R)*P0 + R*P1\n          n = (((stats::qnorm(1-alpha/2)* sqrt(Pbar*(1-Pbar)/R)) +\n                  (stats::qnorm(1-beta[i])*sqrt(P0*(1-P0) + ((P1*(1-P1)*(1-R))/R))))^2) /\n            (((P0-P1)^2) * (1-R))\n\n          or = (P1*(1-P0)) / (P0*(1-P1))\n          N.N1 = abs(n - N1)\n          foo = cbind(P1, N, or, N.N1)\n          foo = foo[which(foo[,3] >= 1),]\n          x = foo[which.min(foo[,4]),]\n\n          or = x[[3]]\n          OR = c(OR, or)\n          OR = round(OR,3)\n\n          p1 = x[[1]]\n          P1.new = c(P1.new, p1)\n          P1.new = round(P1.new,3)\n        }\n      }\n\n    }\n\n    results = NULL\n\n    if(length(alpha) > 1 | length(power) > 1 | length(P0) > 1 | length(N) > 1) {\n      rownum = max(length(alpha), length(power), length(P0), length(OR))\n      for(i in 1:rownum) {\n        results = cbind(alpha, power, P0, P1.new, OR, R, N)\n      }\n      colnames(results) = c(\"alpha\", \"power\", \"P0\", \"P1\", \"OR\", \"R\" ,\"N\")\n    }\n\n    else {\n      results = c(alpha, power, P0, P1.new, OR, R, N)\n      results = data.frame(results)\n      results = t(results)\n      colnames(results) = c(\"alpha\", \"power\", \"P0\", \"P1\", \"OR\", \"R\" ,\"N\")\n    }\n  }\n\n\n\n  if(is.null(N)) {\n\n    beta = 1 - power\n\n\n    P1 = (P0*OR) / (OR*P0 + 1 - P0)\n\n\n    Pbar = (1-R)*P0 + R*P1\n\n    A1 = stats::qnorm(1-alpha/2)* sqrt(Pbar*(1-Pbar)/R)\n    A2 = stats::qnorm(1-beta)*sqrt(P0*(1-P0) + ((P1*(1-P1)*(1-R))/R))\n    A3 = ((P0-P1)^2) * (1-R)\n\n    N = ((A1 + A2)^2) / A3\n    N = ceiling(N)\n\n    P1 = round(P1,3)\n\n\n    results = NULL\n\n    if(length(alpha) > 1 | length(power) > 1 | length(P0) > 1 | length(OR) > 1) {\n      rownum = max(length(alpha), length(power), length(P0), length(OR))\n      for(i in 1:rownum) {\n        results = cbind(alpha, power, P0, P1, OR, R, N)\n      }\n    }\n\n    else {\n      results = c(alpha, power, P0, P1, OR, R, N)\n      results = data.frame(results)\n      results = t(results)\n      colnames(results) = c(\"alpha\", \"power\", \"P0\", \"P1\", \"OR\", \"R\" ,\"N\")\n    }\n  }\n\n  return(results)\n}\n\n\n\n",
    "created" : 1521666089026.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3074587857",
    "id" : "788BB3AB",
    "lastKnownWriteTime" : 1521669575,
    "last_content_update" : 1521669520569,
    "path" : "U:/Research Day 2018/regpoweR/R/logpower_bin4.R",
    "project_path" : "R/logpower_bin4.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}